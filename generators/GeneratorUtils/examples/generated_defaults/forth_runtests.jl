# canonical data version: 1.7.1
# This file was generated by a script.

using Test

include("forth.jl")

# The following lines are top-level comments in canonical-data.json; comments within cases
# are not included. Do not include these comments in the exercise's runtests.jl.
#
# The cases are split into multiple sections, all with the same structure.
# In all cases, the `expected` key is the resulting stack
# after executing the Forth program contained in the `input` key, unless an 'error' exists.

@testset "parsing and numbers" begin
    @testset "numbers just get pushed onto the stack" begin
        @test evaluate(["1 2 3 4 5"]) == [1, 2, 3, 4, 5]
    end
end

@testset "addition" begin
    @testset "can add two numbers" begin
        @test evaluate(["1 2 +"]) == [3]
    end
    @testset "errors if there is nothing on the stack" begin
        @test_throws ArgumentError evaluate(["+"])
    end
    @testset "errors if there is only one value on the stack" begin
        @test_throws ArgumentError evaluate(["1 +"])
    end
end

@testset "subtraction" begin
    @testset "can subtract two numbers" begin
        @test evaluate(["3 4 -"]) == [-1]
    end
    @testset "errors if there is nothing on the stack" begin
        @test_throws ArgumentError evaluate(["-"])
    end
    @testset "errors if there is only one value on the stack" begin
        @test_throws ArgumentError evaluate(["1 -"])
    end
end

@testset "multiplication" begin
    @testset "can multiply two numbers" begin
        @test evaluate(["2 4 *"]) == [8]
    end
    @testset "errors if there is nothing on the stack" begin
        @test_throws ArgumentError evaluate(["*"])
    end
    @testset "errors if there is only one value on the stack" begin
        @test_throws ArgumentError evaluate(["1 *"])
    end
end

@testset "division" begin
    @testset "can divide two numbers" begin
        @test evaluate(["12 3 /"]) == [4]
    end
    @testset "performs integer division" begin
        @test evaluate(["8 3 /"]) == [2]
    end
    @testset "errors if dividing by zero" begin
        @test_throws ArgumentError evaluate(["4 0 /"])
    end
    @testset "errors if there is nothing on the stack" begin
        @test_throws ArgumentError evaluate(["/"])
    end
    @testset "errors if there is only one value on the stack" begin
        @test_throws ArgumentError evaluate(["1 /"])
    end
end

@testset "combined arithmetic" begin
    @testset "addition and subtraction" begin
        @test evaluate(["1 2 + 4 -"]) == [-1]
    end
    @testset "multiplication and division" begin
        @test evaluate(["2 4 * 3 /"]) == [2]
    end
end

@testset "dup" begin
    @testset "copies a value on the stack" begin
        @test evaluate(["1 dup"]) == [1, 1]
    end
    @testset "copies the top value on the stack" begin
        @test evaluate(["1 2 dup"]) == [1, 2, 2]
    end
    @testset "errors if there is nothing on the stack" begin
        @test_throws ArgumentError evaluate(["dup"])
    end
end

@testset "drop" begin
    @testset "removes the top value on the stack if it is the only one" begin
        @test evaluate(["1 drop"]) == []
    end
    @testset "removes the top value on the stack if it is not the only one" begin
        @test evaluate(["1 2 drop"]) == [1]
    end
    @testset "errors if there is nothing on the stack" begin
        @test_throws ArgumentError evaluate(["drop"])
    end
end

@testset "swap" begin
    @testset "swaps the top two values on the stack if they are the only ones" begin
        @test evaluate(["1 2 swap"]) == [2, 1]
    end
    @testset "swaps the top two values on the stack if they are not the only ones" begin
        @test evaluate(["1 2 3 swap"]) == [1, 3, 2]
    end
    @testset "errors if there is nothing on the stack" begin
        @test_throws ArgumentError evaluate(["swap"])
    end
    @testset "errors if there is only one value on the stack" begin
        @test_throws ArgumentError evaluate(["1 swap"])
    end
end

@testset "over" begin
    @testset "copies the second element if there are only two" begin
        @test evaluate(["1 2 over"]) == [1, 2, 1]
    end
    @testset "copies the second element if there are more than two" begin
        @test evaluate(["1 2 3 over"]) == [1, 2, 3, 2]
    end
    @testset "errors if there is nothing on the stack" begin
        @test_throws ArgumentError evaluate(["over"])
    end
    @testset "errors if there is only one value on the stack" begin
        @test_throws ArgumentError evaluate(["1 over"])
    end
end

@testset "user-defined words" begin
    @testset "can consist of built-in words" begin
        @test evaluate([": dup-twice dup dup ;", "1 dup-twice"]) == [1, 1, 1]
    end
    @testset "execute in the right order" begin
        @test evaluate([": countup 1 2 3 ;", "countup"]) == [1, 2, 3]
    end
    @testset "can override other user-defined words" begin
        @test evaluate([": foo dup ;", ": foo dup dup ;", "1 foo"]) == [1, 1, 1]
    end
    @testset "can override built-in words" begin
        @test evaluate([": swap dup ;", "1 swap"]) == [1, 1]
    end
    @testset "can override built-in operators" begin
        @test evaluate([": + * ;", "3 4 +"]) == [12]
    end
    @testset "can use different words with the same name" begin
        @test evaluate([": foo 5 ;", ": bar foo ;", ": foo 6 ;", "bar foo"]) == [5, 6]
    end
    @testset "can define word that uses word with the same name" begin
        @test evaluate([": foo 10 ;", ": foo foo 1 + ;", "foo"]) == [11]
    end
    @testset "cannot redefine numbers" begin
        @test_throws ArgumentError evaluate([": 1 2 ;"])
    end
    @testset "errors if executing a non-existent word" begin
        @test_throws ArgumentError evaluate(["foo"])
    end
end

@testset "case-insensitivity" begin
    @testset "DUP is case-insensitive" begin
        @test evaluate(["1 DUP Dup dup"]) == [1, 1, 1, 1]
    end
    @testset "DROP is case-insensitive" begin
        @test evaluate(["1 2 3 4 DROP Drop drop"]) == [1]
    end
    @testset "SWAP is case-insensitive" begin
        @test evaluate(["1 2 SWAP 3 Swap 4 swap"]) == [2, 3, 4, 1]
    end
    @testset "OVER is case-insensitive" begin
        @test evaluate(["1 2 OVER Over over"]) == [1, 2, 1, 2, 1]
    end
    @testset "user-defined words are case-insensitive" begin
        @test evaluate([": foo dup ;", "1 FOO Foo foo"]) == [1, 1, 1, 1]
    end
    @testset "definitions are case-insensitive" begin
        @test evaluate([": SWAP DUP Dup dup ;", "1 swap"]) == [1, 1, 1, 1]
    end
end


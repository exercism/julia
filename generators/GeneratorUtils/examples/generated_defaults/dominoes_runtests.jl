# canonical data version: 2.1.0
# This file was generated by a script.

using Test

include("dominoes.jl")

# The following lines are top-level comments in canonical-data.json; comments within cases
# are not included. Do not include these comments in the exercise's runtests.jl.
#
# Inputs are given as lists of two-element lists.
# Feel free to convert the input to a sensible type in the specific language
# For example, if the target language has 2-tuples, that is a good candidate.
# 
# There are two levels of this exercise that can be implemented and/or tested:
# 
# 1: Given a list of dominoes, determine whether it can be made into a chain.
# Under this scheme, the submitted code only needs to return a boolean.
# The test code only needs to check that that boolean value matches up.
# 
# 2: Given a list of dominoes, determine one possible chain, if one exists, or else conclude that none can be made.
# Under this scheme, the submitted code needs to either return a chain, or signal that none exists.
# Different languages may do this differently:
# return Option<Vector<Domino>>, return ([]Domino, error), raise exception, etc.
# The test code needs to check that the returned chain is correct (see below).
# 
# It's infeasible to list every single possible result chain in this file.
# That's because for even a simple list [(1, 2), (2, 3), (3, 1)],
# the possible chains are that order, any rotation of that order,
# and any rotation of that order with all dominoes reversed.
# 
# For this reason, this JSON file will only list whether a chain is possible.
# Tracks wishing to verify correct results of the second level must separately perform this verification.
# 
# The properties to verify are:
# 1. The submitted code claims there is a chain if and only if there actually is one.
# 2. The number of dominoes in the output equals the number of dominoes in the input.
# 3a. For each adjacent pair of dominoes ... (a, b), (c, d) ...: b is equal to c.
# 3b. For the dominoes on the ends (a, b) ... (c, d): a is equal to d.
# 4. Every domino appears in the output an equal number of times as the number of times it appears in the input.
# (in other words, the dominoes in the output are the same dominoes as the ones in the input)
# 
# Feel free to examine the Rust track for ideas on implementing the second level verification.

@testset "empty input = empty output" begin
    @test can_chain([]) == true
end

@testset "singleton input = singleton output" begin
    @test can_chain([[1, 1]]) == true
end

@testset "singleton that can't be chained" begin
    @test can_chain([[1, 2]]) == false
end

@testset "three elements" begin
    @test can_chain([[1, 2], [3, 1], [2, 3]]) == true
end

@testset "can reverse dominoes" begin
    @test can_chain([[1, 2], [1, 3], [2, 3]]) == true
end

@testset "can't be chained" begin
    @test can_chain([[1, 2], [4, 1], [2, 3]]) == false
end

@testset "disconnected - simple" begin
    @test can_chain([[1, 1], [2, 2]]) == false
end

@testset "disconnected - double loop" begin
    @test can_chain([[1, 2], [2, 1], [3, 4], [4, 3]]) == false
end

@testset "disconnected - single isolated" begin
    @test can_chain([[1, 2], [2, 3], [3, 1], [4, 4]]) == false
end

@testset "need backtrack" begin
    @test can_chain([[1, 2], [2, 3], [3, 1], [2, 4], [2, 4]]) == true
end

@testset "separate loops" begin
    @test can_chain([[1, 2], [2, 3], [3, 1], [1, 1], [2, 2], [3, 3]]) == true
end

@testset "nine elements" begin
    @test can_chain([[1, 2], [5, 3], [3, 1], [1, 2], [2, 4], [1, 6], [2, 3], [3, 4], [5, 6]]) == true
end


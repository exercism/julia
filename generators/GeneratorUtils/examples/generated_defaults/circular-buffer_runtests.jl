# canonical data version: 1.2.0
# This file was generated by a script.

using Test

include("circular-buffer.jl")

# The following lines are top-level comments in canonical-data.json; comments within cases
# are not included. Do not include these comments in the exercise's runtests.jl.
#
# In general, these circular buffers are expected to be stateful,
# and each language will operate on them differently.
# Tests tend to perform a series of operations, some of which expect a certain result.
# As such, this common test suite can only say in abstract terms what should be done.
# 
# Tests will contain a number of operations. The operation will be specified in the `operation` key.
# Based on the operation, other keys may be present.
# read: Reading from the buffer should succeed if and only if `should_succeed` is true.
#   If it should succeed, it should produce the item at `expected`. 
#   If it should fail, `expected` will not be present. 
# write: Writing the item located at `item` should succeed if and only if `should_succeed` is true.
# overwrite: Write the item located at `item` into the buffer, replacing the oldest item if necessary.
# clear: Clear the buffer.
# 
# Failure of either `read` or `write` may be indicated in a manner appropriate for your language:
# Raising an exception, returning (int, error), returning Option<int>, etc.
# 
# Finally, note that all values are integers.
# If your language contains generics, you may consider allowing buffers to contain other types.
# Tests for that are not included here.
# 

@testset "reading empty buffer should fail" begin
    @test run(1, OrderedDict{String,Any}[Dict("operation" => "read", "should_succeed" => false)]) == Dict()
end

@testset "can read an item just written" begin
    @test run(1, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 1)]) == Dict()
end

@testset "each item may only be read once" begin
    @test run(1, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 1), Dict("operation" => "read", "should_succeed" => false)]) == Dict()
end

@testset "items are read in the order they are written" begin
    @test run(2, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "write", "item" => 2, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 1), Dict("operation" => "read", "should_succeed" => true, "expected" => 2)]) == Dict()
end

@testset "full buffer can't be written to" begin
    @test run(1, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "write", "item" => 2, "should_succeed" => false)]) == Dict()
end

@testset "a read frees up capacity for another write" begin
    @test run(1, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 1), Dict("operation" => "write", "item" => 2, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 2)]) == Dict()
end

@testset "read position is maintained even across multiple writes" begin
    @test run(3, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "write", "item" => 2, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 1), Dict("operation" => "write", "item" => 3, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 2), Dict("operation" => "read", "should_succeed" => true, "expected" => 3)]) == Dict()
end

@testset "items cleared out of buffer can't be read" begin
    @test run(1, OrderedDict{String,V} where V[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "clear"), Dict("operation" => "read", "should_succeed" => false)]) == Dict()
end

@testset "clear frees up capacity for another write" begin
    @test run(1, OrderedDict{String,V} where V[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "clear"), Dict("operation" => "write", "item" => 2, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 2)]) == Dict()
end

@testset "clear does nothing on empty buffer" begin
    @test run(1, OrderedDict{String,V} where V[Dict("operation" => "clear"), Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 1)]) == Dict()
end

@testset "overwrite acts like write on non-full buffer" begin
    @test run(2, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "overwrite", "item" => 2), Dict("operation" => "read", "should_succeed" => true, "expected" => 1), Dict("operation" => "read", "should_succeed" => true, "expected" => 2)]) == Dict()
end

@testset "overwrite replaces the oldest item on full buffer" begin
    @test run(2, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "write", "item" => 2, "should_succeed" => true), Dict("operation" => "overwrite", "item" => 3), Dict("operation" => "read", "should_succeed" => true, "expected" => 2), Dict("operation" => "read", "should_succeed" => true, "expected" => 3)]) == Dict()
end

@testset "overwrite replaces the oldest item remaining in buffer following a read" begin
    @test run(3, OrderedDict{String,Any}[Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "write", "item" => 2, "should_succeed" => true), Dict("operation" => "write", "item" => 3, "should_succeed" => true), Dict("operation" => "read", "should_succeed" => true, "expected" => 1), Dict("operation" => "write", "item" => 4, "should_succeed" => true), Dict("operation" => "overwrite", "item" => 5), Dict("operation" => "read", "should_succeed" => true, "expected" => 3), Dict("operation" => "read", "should_succeed" => true, "expected" => 4), Dict("operation" => "read", "should_succeed" => true, "expected" => 5)]) == Dict()
end

@testset "initial clear does not affect wrapping around" begin
    @test run(2, OrderedDict{String,V} where V[Dict("operation" => "clear"), Dict("operation" => "write", "item" => 1, "should_succeed" => true), Dict("operation" => "write", "item" => 2, "should_succeed" => true), Dict("operation" => "overwrite", "item" => 3), Dict("operation" => "overwrite", "item" => 4), Dict("operation" => "read", "should_succeed" => true, "expected" => 3), Dict("operation" => "read", "should_succeed" => true, "expected" => 4), Dict("operation" => "read", "should_succeed" => false)]) == Dict()
end


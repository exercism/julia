# canonical data version: 2.4.1
# This file was generated by a script.

using Test

include("list-ops.jl")

# The following lines are top-level comments in canonical-data.json; comments within cases
# are not included. Do not include these comments in the exercise's runtests.jl.
#
# Though there are no specifications here for dealing with large lists,
# implementers may add tests for handling large lists to ensure that the
# solutions have thought about performance concerns.

@testset "append entries to a list and return the new list" begin
    @testset "empty lists" begin
        @test append([], []) == []
    end
    @testset "list to empty list" begin
        @test append([], [1, 2, 3, 4]) == [1, 2, 3, 4]
    end
    @testset "non-empty lists" begin
        @test append([1, 2], [2, 3, 4, 5]) == [1, 2, 2, 3, 4, 5]
    end
end

@testset "concatenate a list of lists" begin
    @testset "empty list" begin
        @test concat([]) == []
    end
    @testset "list of lists" begin
        @test concat(Array{T,1} where T[[1, 2], [3], Any[], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]
    end
    @testset "list of nested lists" begin
        @test concat(Array{T,1} where T[[[1], [2]], [[3]], Array{Any,1}[[]], [[4, 5, 6]]]) == Array{T,1} where T[[1], [2], [3], Any[], [4, 5, 6]]
    end
end

@testset "filter list returning only values that satisfy the filter function" begin
    @testset "empty list" begin
        @test filter([], "(x) -> x modulo 2 == 1") == []
    end
    @testset "non-empty list" begin
        @test filter([1, 2, 3, 5], "(x) -> x modulo 2 == 1") == [1, 3, 5]
    end
end

@testset "returns the length of a list" begin
    @testset "empty list" begin
        @test length([]) == 0
    end
    @testset "non-empty list" begin
        @test length([1, 2, 3, 4]) == 4
    end
end

@testset "return a list of elements whose values equal the list value transformed by the mapping function" begin
    @testset "empty list" begin
        @test map([], "(x) -> x + 1") == []
    end
    @testset "non-empty list" begin
        @test map([1, 3, 5, 7], "(x) -> x + 1") == [2, 4, 6, 8]
    end
end

@testset "folds (reduces) the given list from the left with a function" begin
    @testset "empty list" begin
        @test foldl([], 2, "(x, y) -> x * y") == 2
    end
    @testset "direction independent function applied to non-empty list" begin
        @test foldl([1, 2, 3, 4], 5, "(x, y) -> x + y") == 15
    end
    @testset "direction dependent function applied to non-empty list" begin
        @test foldl([2, 5], 5, "(x, y) -> x / y") == 0
    end
end

@testset "folds (reduces) the given list from the right with a function" begin
    @testset "empty list" begin
        @test foldr([], 2, "(x, y) -> x * y") == 2
    end
    @testset "direction independent function applied to non-empty list" begin
        @test foldr([1, 2, 3, 4], 5, "(x, y) -> x + y") == 15
    end
    @testset "direction dependent function applied to non-empty list" begin
        @test foldr([2, 5], 5, "(x, y) -> x / y") == 2
    end
end

@testset "reverse the elements of the list" begin
    @testset "empty list" begin
        @test reverse([]) == []
    end
    @testset "non-empty list" begin
        @test reverse([1, 3, 5, 7]) == [7, 5, 3, 1]
    end
    @testset "list of lists is not flattened" begin
        @test reverse(Array{T,1} where T[[1, 2], [3], Any[], [4, 5, 6]]) == Array{T,1} where T[[4, 5, 6], Any[], [3], [1, 2]]
    end
end


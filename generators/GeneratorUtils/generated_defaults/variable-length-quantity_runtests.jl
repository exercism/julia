# canonical data version: 1.2.0
# This file was generated by a script.

using Test

include("variable-length-quantity.jl")

# The following lines are top-level comments in canonical-data.json; comments within cases
# are not included. Do not include these comments in the exercise's runtests.jl.
#
# JSON doesn't allow hexadecimal literals.
# All numbers are given as decimal literals instead.
# An error should be expected for incomplete sequences.
# It is highly recommended that your track's test generator display all numbers as hexadecimal literals.

@testset "Encode a series of integers, producing a series of bytes." begin
    @testset "zero" begin
        @test encode([0]) == [0]
    end
    @testset "arbitrary single byte" begin
        @test encode([64]) == [64]
    end
    @testset "largest single byte" begin
        @test encode([127]) == [127]
    end
    @testset "smallest double byte" begin
        @test encode([128]) == [129, 0]
    end
    @testset "arbitrary double byte" begin
        @test encode([8192]) == [192, 0]
    end
    @testset "largest double byte" begin
        @test encode([16383]) == [255, 127]
    end
    @testset "smallest triple byte" begin
        @test encode([16384]) == [129, 128, 0]
    end
    @testset "arbitrary triple byte" begin
        @test encode([1048576]) == [192, 128, 0]
    end
    @testset "largest triple byte" begin
        @test encode([2097151]) == [255, 255, 127]
    end
    @testset "smallest quadruple byte" begin
        @test encode([2097152]) == [129, 128, 128, 0]
    end
    @testset "arbitrary quadruple byte" begin
        @test encode([134217728]) == [192, 128, 128, 0]
    end
    @testset "largest quadruple byte" begin
        @test encode([268435455]) == [255, 255, 255, 127]
    end
    @testset "smallest quintuple byte" begin
        @test encode([268435456]) == [129, 128, 128, 128, 0]
    end
    @testset "arbitrary quintuple byte" begin
        @test encode([4278190080]) == [143, 248, 128, 128, 0]
    end
    @testset "maximum 32-bit integer input" begin
        @test encode([4294967295]) == [143, 255, 255, 255, 127]
    end
    @testset "two single-byte values" begin
        @test encode([64, 127]) == [64, 127]
    end
    @testset "two multi-byte values" begin
        @test encode([16384, 1193046]) == [129, 128, 0, 200, 232, 86]
    end
    @testset "many multi-byte values" begin
        @test encode([8192, 1193046, 268435455, 0, 16383, 16384]) == [192, 0, 200, 232, 86, 255, 255, 255, 127, 0, 255, 127, 129, 128, 0]
    end
end

@testset "Decode a series of bytes, producing a series of integers." begin
    @testset "one byte" begin
        @test decode([127]) == [127]
    end
    @testset "two bytes" begin
        @test decode([192, 0]) == [8192]
    end
    @testset "three bytes" begin
        @test decode([255, 255, 127]) == [2097151]
    end
    @testset "four bytes" begin
        @test decode([129, 128, 128, 0]) == [2097152]
    end
    @testset "maximum 32-bit integer" begin
        @test decode([143, 255, 255, 255, 127]) == [4294967295]
    end
    @testset "incomplete sequence causes error" begin
        @test_throws ArgumentError decode([255])
    end
    @testset "incomplete sequence causes error, even if value is zero" begin
        @test_throws ArgumentError decode([128])
    end
    @testset "multiple values" begin
        @test decode([192, 0, 200, 232, 86, 255, 255, 255, 127, 0, 255, 127, 129, 128, 0]) == [8192, 1193046, 268435455, 0, 16383, 16384]
    end
end


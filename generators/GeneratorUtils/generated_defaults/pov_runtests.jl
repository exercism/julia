# canonical data version: 1.3.0
# This file was generated by a script.

using Test

include("pov.jl")

@testset "Reroot a tree so that its root is the specified node." begin
    @testset "Results in the same tree if the input tree is a singleton" begin
        @test from_pov(Dict("label" => "x"), "x") == Dict("label" => "x")
    end
    @testset "Can reroot a tree with a parent and one sibling" begin
        @test from_pov(Dict("label" => "parent", "children" => [Dict("label" => "x"), Dict("label" => "sibling")]), "x") == Dict("label" => "x", "children" => OrderedDict{String,Any}[Dict("label" => "parent", "children" => [Dict("label" => "sibling")])])
    end
    @testset "Can reroot a tree with a parent and many siblings" begin
        @test from_pov(Dict("label" => "parent", "children" => [Dict("label" => "a"), Dict("label" => "x"), Dict("label" => "b"), Dict("label" => "c")]), "x") == Dict("label" => "x", "children" => OrderedDict{String,Any}[Dict("label" => "parent", "children" => [Dict("label" => "a"), Dict("label" => "b"), Dict("label" => "c")])])
    end
    @testset "Can reroot a tree with new root deeply nested in tree" begin
        @test from_pov(Dict("label" => "level-0", "children" => OrderedDict{String,Any}[Dict("label" => "level-1", "children" => OrderedDict{String,Any}[Dict("label" => "level-2", "children" => OrderedDict{String,Any}[Dict("label" => "level-3", "children" => [Dict("label" => "x")])])])]), "x") == Dict("label" => "x", "children" => OrderedDict{String,Any}[Dict("label" => "level-3", "children" => OrderedDict{String,Any}[Dict("label" => "level-2", "children" => OrderedDict{String,Any}[Dict("label" => "level-1", "children" => [Dict("label" => "level-0")])])])])
    end
    @testset "Moves children of the new root to same level as former parent" begin
        @test from_pov(Dict("label" => "parent", "children" => OrderedDict{String,Any}[Dict("label" => "x", "children" => [Dict("label" => "kid-0"), Dict("label" => "kid-1")])]), "x") == Dict("label" => "x", "children" => [Dict("label" => "kid-0"), Dict("label" => "kid-1"), Dict("label" => "parent")])
    end
    @testset "Can reroot a complex tree with cousins" begin
        @test from_pov(Dict("label" => "grandparent", "children" => OrderedDict{String,Any}[Dict("label" => "parent", "children" => OrderedDict{String,V} where V[Dict("label" => "x", "children" => [Dict("label" => "kid-0"), Dict("label" => "kid-1")]), Dict("label" => "sibling-0"), Dict("label" => "sibling-1")]), Dict("label" => "uncle", "children" => [Dict("label" => "cousin-0"), Dict("label" => "cousin-1")])]), "x") == Dict("label" => "x", "children" => OrderedDict{String,V} where V[Dict("label" => "kid-1"), Dict("label" => "kid-0"), Dict("label" => "parent", "children" => OrderedDict{String,V} where V[Dict("label" => "sibling-0"), Dict("label" => "sibling-1"), Dict("label" => "grandparent", "children" => OrderedDict{String,Any}[Dict("label" => "uncle", "children" => [Dict("label" => "cousin-0"), Dict("label" => "cousin-1")])])])])
    end
    @testset "Errors if target does not exist in a singleton tree" begin
        @test from_pov(Dict("label" => "x"), "nonexistent") == nothing
    end
    @testset "Errors if target does not exist in a large tree" begin
        @test from_pov(Dict("label" => "parent", "children" => OrderedDict{String,V} where V[Dict("label" => "x", "children" => [Dict("label" => "kid-0"), Dict("label" => "kid-1")]), Dict("label" => "sibling-0"), Dict("label" => "sibling-1")]), "nonexistent") == nothing
    end
end

@testset "Given two nodes, find the path between them" begin
    @testset "Can find path to parent" begin
        @test path_to("x", "parent", Dict("label" => "parent", "children" => [Dict("label" => "x"), Dict("label" => "sibling")])) == ["x", "parent"]
    end
    @testset "Can find path to sibling" begin
        @test path_to("x", "b", Dict("label" => "parent", "children" => [Dict("label" => "a"), Dict("label" => "x"), Dict("label" => "b"), Dict("label" => "c")])) == ["x", "parent", "b"]
    end
    @testset "Can find path to cousin" begin
        @test path_to("x", "cousin-1", Dict("label" => "grandparent", "children" => OrderedDict{String,Any}[Dict("label" => "parent", "children" => OrderedDict{String,V} where V[Dict("label" => "x", "children" => [Dict("label" => "kid-0"), Dict("label" => "kid-1")]), Dict("label" => "sibling-0"), Dict("label" => "sibling-1")]), Dict("label" => "uncle", "children" => [Dict("label" => "cousin-0"), Dict("label" => "cousin-1")])])) == ["x", "parent", "grandparent", "uncle", "cousin-1"]
    end
    @testset "Can find path not involving root" begin
        @test path_to("x", "sibling-1", Dict("label" => "grandparent", "children" => OrderedDict{String,Any}[Dict("label" => "parent", "children" => [Dict("label" => "x"), Dict("label" => "sibling-0"), Dict("label" => "sibling-1")])])) == ["x", "parent", "sibling-1"]
    end
    @testset "Can find path from nodes other than x" begin
        @test path_to("a", "c", Dict("label" => "parent", "children" => [Dict("label" => "a"), Dict("label" => "x"), Dict("label" => "b"), Dict("label" => "c")])) == ["a", "parent", "c"]
    end
    @testset "Errors if destination does not exist" begin
        @test path_to("x", "nonexistent", Dict("label" => "parent", "children" => OrderedDict{String,V} where V[Dict("label" => "x", "children" => [Dict("label" => "kid-0"), Dict("label" => "kid-1")]), Dict("label" => "sibling-0"), Dict("label" => "sibling-1")])) == nothing
    end
    @testset "Errors if source does not exist" begin
        @test path_to("nonexistent", "x", Dict("label" => "parent", "children" => OrderedDict{String,V} where V[Dict("label" => "x", "children" => [Dict("label" => "kid-0"), Dict("label" => "kid-1")]), Dict("label" => "sibling-0"), Dict("label" => "sibling-1")])) == nothing
    end
end


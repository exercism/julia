# canonical data version: 2.0.0
# This file was generated by a script.

using Test

include("react.jl")

# The following lines are top-level comments in canonical-data.json; comments within cases
# are not included. Do not include these comments in the exercise's runtests.jl.
#
# Note that, due to the nature of this exercise,
# the tests are specified using their cells and a series of operations to perform on the cells.
# 
# Each object in the `cells` array has a `name` and `type` (`input` or `output`).
# input cells have an `initial_value`, and compute cells have `inputs` and `compute_function`
# 
# Each object in the `operations` array has a `type`.
# Depending on the type, it also has additional fields.
# The possible types and semantics of their fields are as follows:
# 
# * expect_cell_value (`cell`, `value`): Expect that cell `cell` has value `value`.
# * set_value (`cell`, `value`, optionally `expect_callbacks`, `expect_callbacks_not_to_be_called`): Sets input cell `cell` to value `value`.
#   Expect that, as a result, all callbacks in `expect_callbacks` (if present) were called exactly once with the designated value
#   Expect that no callbacks in `expect_callbacks_not_to_be_called` (if present) were called as a result.
# * add_callback (`cell`, `name`): Adds a callback to cell `cell`. Store the callback ID in a variable named `name`.
#   all callbacks are assumed to simply store the values they're called with in some array.
# * remove_callback (`cell`, `name`): Removes the callback `name` from cell `cell`.
# 
# Additional notes:
# 
# These tests only describe compute cells with up to two inputs.
# Some languages may choose to have two functions: create_compute1 and create_compute2.
# The compiler can then ensure that you never pass a two-input function to a one-input compute cell.
# (This benefit only exists for statically typed languages).
# If your track does this, you should test that all combinations of
# (compute1, compute2) can depend on (input, compute1, compute2) are tested.
# Other languages simply have a single create_compute function, taking a list of input cells.
# Of the languages in this category, there are two subcategories:
# - In some languages, the compute function might take as many inputs as there are input cells.
#   (it might be very difficult to write the type signature for create_compute in statically typed languages!)
# - In other languages, the compute function might always take a single input (the list of values)
#   (again this gives up the ability to check that the arities match)
# Both subcategories using create_compute have the benefit of more flexibility in arity,
# fewer repetitive tests (only need to test that compute cells can depend on compute cells and input cells),
# and likely less repetitive code.
# 
# Finally, note that all values are integers.
# If your language supports generics, you may consider allowing reactors to act on other types.
# Tests for that are not included here.
# 

@testset "input cells have a value" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 10)], OrderedDict{String,Any}[Dict("type" => "expect_cell_value", "cell" => "input", "value" => 10)]) == Dict()
end

@testset "an input cell's value can be set" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 4)], OrderedDict{String,Any}[Dict("type" => "set_value", "cell" => "input", "value" => 20), Dict("type" => "expect_cell_value", "cell" => "input", "value" => 20)]) == Dict()
end

@testset "compute cells calculate initial value" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "output", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1")], OrderedDict{String,Any}[Dict("type" => "expect_cell_value", "cell" => "output", "value" => 2)]) == Dict()
end

@testset "compute cells take inputs in the right order" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "one", "type" => "input", "initial_value" => 1), Dict("name" => "two", "type" => "input", "initial_value" => 2), Dict("name" => "output", "type" => "compute", "inputs" => ["one", "two"], "compute_function" => "inputs[0] + inputs[1] * 10")], OrderedDict{String,Any}[Dict("type" => "expect_cell_value", "cell" => "output", "value" => 21)]) == Dict()
end

@testset "compute cells update value when dependencies are changed" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "output", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1")], OrderedDict{String,Any}[Dict("type" => "set_value", "cell" => "input", "value" => 3), Dict("type" => "expect_cell_value", "cell" => "output", "value" => 4)]) == Dict()
end

@testset "compute cells can depend on other compute cells" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "times_two", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] * 2"), Dict("name" => "times_thirty", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] * 30"), Dict("name" => "output", "type" => "compute", "inputs" => ["times_two", "times_thirty"], "compute_function" => "inputs[0] + inputs[1]")], OrderedDict{String,Any}[Dict("type" => "expect_cell_value", "cell" => "output", "value" => 32), Dict("type" => "set_value", "cell" => "input", "value" => 3), Dict("type" => "expect_cell_value", "cell" => "output", "value" => 96)]) == Dict()
end

@testset "compute cells fire callbacks" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "output", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1")], OrderedDict{String,V} where V[Dict("type" => "add_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "set_value", "cell" => "input", "value" => 3, "expect_callbacks" => Dict("callback1" => 4))]) == Dict()
end

@testset "callback cells only fire on change" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "output", "type" => "compute", "inputs" => ["input"], "compute_function" => "if inputs[0] < 3 then 111 else 222")], OrderedDict{String,V} where V[Dict("type" => "add_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "set_value", "cell" => "input", "value" => 2, "expect_callbacks_not_to_be_called" => ["callback1"]), Dict("type" => "set_value", "cell" => "input", "value" => 4, "expect_callbacks" => Dict("callback1" => 222))]) == Dict()
end

@testset "callbacks do not report already reported values" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "output", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1")], OrderedDict{String,V} where V[Dict("type" => "add_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "set_value", "cell" => "input", "value" => 2, "expect_callbacks" => Dict("callback1" => 3)), Dict("type" => "set_value", "cell" => "input", "value" => 3, "expect_callbacks" => Dict("callback1" => 4))]) == Dict()
end

@testset "callbacks can fire from multiple cells" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "plus_one", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1"), Dict("name" => "minus_one", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] - 1")], OrderedDict{String,V} where V[Dict("type" => "add_callback", "cell" => "plus_one", "name" => "callback1"), Dict("type" => "add_callback", "cell" => "minus_one", "name" => "callback2"), Dict("type" => "set_value", "cell" => "input", "value" => 10, "expect_callbacks" => Dict("callback1" => 11, "callback2" => 9))]) == Dict()
end

@testset "callbacks can be added and removed" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 11), Dict("name" => "output", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1")], OrderedDict{String,V} where V[Dict("type" => "add_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "add_callback", "cell" => "output", "name" => "callback2"), Dict("type" => "set_value", "cell" => "input", "value" => 31, "expect_callbacks" => Dict("callback1" => 32, "callback2" => 32)), Dict("type" => "remove_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "add_callback", "cell" => "output", "name" => "callback3"), Dict("type" => "set_value", "cell" => "input", "value" => 41, "expect_callbacks" => Dict("callback2" => 42, "callback3" => 42), "expect_callbacks_not_to_be_called" => ["callback1"])]) == Dict()
end

@testset "removing a callback multiple times doesn't interfere with other callbacks" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "output", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1")], OrderedDict{String,V} where V[Dict("type" => "add_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "add_callback", "cell" => "output", "name" => "callback2"), Dict("type" => "remove_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "remove_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "remove_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "set_value", "cell" => "input", "value" => 2, "expect_callbacks" => Dict("callback2" => 3), "expect_callbacks_not_to_be_called" => ["callback1"])]) == Dict()
end

@testset "callbacks should only be called once even if multiple dependencies change" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "plus_one", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1"), Dict("name" => "minus_one1", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] - 1"), Dict("name" => "minus_one2", "type" => "compute", "inputs" => ["minus_one1"], "compute_function" => "inputs[0] - 1"), Dict("name" => "output", "type" => "compute", "inputs" => ["plus_one", "minus_one2"], "compute_function" => "inputs[0] * inputs[1]")], OrderedDict{String,V} where V[Dict("type" => "add_callback", "cell" => "output", "name" => "callback1"), Dict("type" => "set_value", "cell" => "input", "value" => 4, "expect_callbacks" => Dict("callback1" => 10))]) == Dict()
end

@testset "callbacks should not be called if dependencies change but output value doesn't change" begin
    @test react(OrderedDict{String,Any}[Dict("name" => "input", "type" => "input", "initial_value" => 1), Dict("name" => "plus_one", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] + 1"), Dict("name" => "minus_one", "type" => "compute", "inputs" => ["input"], "compute_function" => "inputs[0] - 1"), Dict("name" => "always_two", "type" => "compute", "inputs" => ["plus_one", "minus_one"], "compute_function" => "inputs[0] - inputs[1]")], OrderedDict{String,V} where V[Dict("type" => "add_callback", "cell" => "always_two", "name" => "callback1"), Dict("type" => "set_value", "cell" => "input", "value" => 2, "expect_callbacks_not_to_be_called" => ["callback1"]), Dict("type" => "set_value", "cell" => "input", "value" => 3, "expect_callbacks_not_to_be_called" => ["callback1"]), Dict("type" => "set_value", "cell" => "input", "value" => 4, "expect_callbacks_not_to_be_called" => ["callback1"]), Dict("type" => "set_value", "cell" => "input", "value" => 5, "expect_callbacks_not_to_be_called" => ["callback1"])]) == Dict()
end


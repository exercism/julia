# canonical data version: 1.1.0
# This file was generated by a script.

using Test

include("zipper.jl")

# The following lines are top-level comments in canonical-data.json; comments within cases
# are not included. Do not include these comments in the exercise's runtests.jl.
#
#  The test cases for this exercise include an initial tree and a     
#  series of operations to perform on the initial tree.               
#                                                                     
#  Trees are encoded as nested objects. Each node in the tree has     
#  three members: 'value', 'left', and 'right'. Each value is a       
#  number (for simplicity). Left and right are trees. An empty node   
#  is encoded as null.                                                
#                                                                     
#  Each operation in the operations list is an object. The function   
#  name is listed under 'operation'. If the function requires         
#  arguments, the argument is listed under 'item'. Some functions     
#  require values (i.e.  numbers), while others require trees.        
#  Comments are always optional and can be used almost anywhere.      

@testset "data is retained" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), [Dict("operation" => "to_tree")]) == Dict("type" => "tree", "value" => Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)))
end

@testset "left, right and value" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), [Dict("operation" => "left"), Dict("operation" => "right"), Dict("operation" => "value")]) == Dict("type" => "int", "value" => 3)
end

@testset "dead end" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), [Dict("operation" => "left"), Dict("operation" => "left")]) == Dict("type" => "zipper", "value" => nothing)
end

@testset "tree from deep focus" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), [Dict("operation" => "left"), Dict("operation" => "right"), Dict("operation" => "to_tree")]) == Dict("type" => "tree", "value" => Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)))
end

@testset "traversing up from top" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), [Dict("operation" => "up")]) == Dict("type" => "zipper", "value" => nothing)
end

@testset "left, right, and up" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), [Dict("operation" => "left"), Dict("operation" => "up"), Dict("operation" => "right"), Dict("operation" => "up"), Dict("operation" => "left"), Dict("operation" => "right"), Dict("operation" => "value")]) == Dict("type" => "int", "value" => 3)
end

@testset "set_value" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), OrderedDict{String,V} where V[Dict("operation" => "left"), Dict("operation" => "set_value", "item" => 5), Dict("operation" => "to_tree")]) == Dict("type" => "tree", "value" => Dict("value" => 1, "left" => Dict("value" => 5, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)))
end

@testset "set_value after traversing up" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), OrderedDict{String,V} where V[Dict("operation" => "left"), Dict("operation" => "right"), Dict("operation" => "up"), Dict("operation" => "set_value", "item" => 5), Dict("operation" => "to_tree")]) == Dict("type" => "tree", "value" => Dict("value" => 1, "left" => Dict("value" => 5, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)))
end

@testset "set_left with leaf" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), OrderedDict{String,V} where V[Dict("operation" => "left"), Dict("operation" => "set_left", "item" => Dict("value" => 5, "left" => nothing, "right" => nothing)), Dict("operation" => "to_tree")]) == Dict("type" => "tree", "value" => Dict("value" => 1, "left" => Dict("value" => 2, "left" => Dict("value" => 5, "left" => nothing, "right" => nothing), "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)))
end

@testset "set_right with null" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), OrderedDict{String,V} where V[Dict("operation" => "left"), Dict("operation" => "set_right", "item" => nothing), Dict("operation" => "to_tree")]) == Dict("type" => "tree", "value" => Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => nothing), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)))
end

@testset "set_right with subtree" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), OrderedDict{String,V} where V[Dict("operation" => "set_right", "item" => Dict("value" => 6, "left" => Dict("value" => 7, "left" => nothing, "right" => nothing), "right" => Dict("value" => 8, "left" => nothing, "right" => nothing))), Dict("operation" => "to_tree")]) == Dict("type" => "tree", "value" => Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 6, "left" => Dict("value" => 7, "left" => nothing, "right" => nothing), "right" => Dict("value" => 8, "left" => nothing, "right" => nothing))))
end

@testset "set_value on deep focus" begin
    @test expected_value(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), OrderedDict{String,V} where V[Dict("operation" => "left"), Dict("operation" => "right"), Dict("operation" => "set_value", "item" => 5), Dict("operation" => "to_tree")]) == Dict("type" => "tree", "value" => Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 5, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)))
end

@testset "different paths to same zipper" begin
    @test same_result_from_operations(Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), [Dict("operation" => "left"), Dict("operation" => "up"), Dict("operation" => "right")]) == Dict("type" => "zipper", "initialTree" => Dict("value" => 1, "left" => Dict("value" => 2, "left" => nothing, "right" => Dict("value" => 3, "left" => nothing, "right" => nothing)), "right" => Dict("value" => 4, "left" => nothing, "right" => nothing)), "operations" => [Dict("operation" => "right")])
end

